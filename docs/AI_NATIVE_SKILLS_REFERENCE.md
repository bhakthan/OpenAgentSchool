# AI-Native Skills: Revolutionary Practices from Industry Leaders

## Overview

This document captures the novel, AI-native practices pioneered by OpenAI (Codex) and Anthropic (Claude Code) that are fundamentally changing how organizations develop software, debug systems, and collaborate across teams.

## Table of Contents

1. [OpenAI Codex Practices](#openai-codex-practices)
2. [Anthropic Claude Code Practices](#anthropic-claude-code-practices)
3. [Novel Practices Summary](#novel-practices-summary)
4. [Learning Path Organization](#learning-path-organization)

---

## OpenAI Codex Practices

### üîß 1. Code Understanding
**Core Capability:** Navigate unfamiliar code for onboarding or incident response

**Traditional Methods:**
- Manual code reading
- Documentation searching
- Asking team members
- Trial and error debugging

**AI-Native Methods:**
- ‚≠ê **Ask Mode Bug Detection**: Query across multiple files to find bugs systematically
- ‚≠ê **Stack Trace Navigation**: Jump directly from error to relevant code sections
- ‚≠ê **Cross-Language LLM Search**: Replace grep with semantic understanding across languages

**Impact:** Faster debugging, reduced onboarding friction

**Real-World Applications:**
- Locate feature logic and trace data flows
- Fill in missing architecture/documentation gaps
- Stack trace resolution with "jump to file"
- Terraform and Python search across repositories

---

### üõ† 2. Refactoring & Migrations
**Core Capability:** Multi-file API updates and pattern swaps

**Traditional Methods:**
- Manual find-and-replace
- Individual file updates
- Manual PR creation
- Written change documentation

**AI-Native Methods:**
- ‚≠ê **Mass Code Changes + PR Automation**: Automated PRs for sweeping changes
- ‚≠ê **AI-Generated Markdown Diff Summaries**: Automatic impact documentation

**Impact:** Cleaner code, faster migrations

**Real-World Applications:**
- Automatic PRs for sweeping changes
- Summarize change impact in markdown
- Break down large modules, modernize legacy code
- Multi-file API updates and pattern swaps

---

### üöÄ 3. Performance Optimization
**Core Capability:** Identify and fix performance bottlenecks

**Traditional Methods:**
- Manual profiling
- Code review for performance
- Separate optimization phases

**AI-Native Methods:**
- ‚≠ê **Performance Bottleneck Detection + Fix**: Single-step identification and solution
- ‚≠ê **5-Minute Performance Audits**: Rapid systematic performance reviews

**Impact:** Reduced tech debt, higher reliability

**Real-World Applications:**
- Identify memory-intensive or slow code paths
- Batch expensive DB calls
- Suggest loop/query optimizations
- Spot deprecated or risky patterns

---

### ‚úÖ 4. Test Coverage
**Core Capability:** Comprehensive test generation and maintenance

**Traditional Methods:**
- Manual test writing
- Test-driven development
- Post-development testing

**AI-Native Methods:**
- ‚≠ê **Autogenerated Test PRs While Offline**: Tests created during downtime
- ‚≠ê **CI Acceleration Through AI Test Handoffs**: Seamless CI integration

**Impact:** Improved quality with lower effort

**Real-World Applications:**
- Generate unit/integration/property-based tests
- Cover edge cases (nulls, max length, invalid states)
- Write tests post-fix or mid-refactor
- CI-ready test PRs overnight

---

### ‚ö° 5. Development Velocity
**Core Capability:** Rapid scaffolding and prototype creation

**Traditional Methods:**
- Manual scaffolding
- Template-based generation
- Sequential development

**AI-Native Methods:**
- ‚≠ê **User Request to Prototype in One Prompt**: Direct requirement-to-code translation
- ‚≠ê **Async AI Work During Meetings**: AI continues work while humans are busy

**Impact:** More output under time pressure

**Real-World Applications:**
- Scaffolding folders, APIs, telemetry hooks
- Drafting rollout scripts or last-mile fixes
- Turning product feedback into starter code

---

### üîÅ 6. Staying in Flow
**Core Capability:** Maintaining developer focus and context

**Traditional Methods:**
- Context switching
- Manual task management
- Sequential work only

**AI-Native Methods:**
- ‚≠ê **Prompt-Based Flow Capture + Revisit**: Preserve context across interruptions
- ‚≠ê **AI-Driven Side Quests**: Parallel work streams without losing focus

**Impact:** Fewer interruptions, faster recovery

**Real-World Applications:**
- AI as async co-pilot for unfinished tasks
- Turn notes/slack threads/issues into code
- Avoid context-switching with task queue

---

### üéØ 7. Exploration & Ideation
**Core Capability:** Alternative solution exploration

**Traditional Methods:**
- Manual brainstorming
- Sequential exploration
- Limited solution space

**AI-Native Methods:**
- ‚≠ê **"How Else Could We Design This?" Prompting**: Systematic alternative exploration
- ‚≠ê **Codebase Similarity Detection for Bugs**: Pattern-based issue identification

**Impact:** Better designs, proactive maintenance

**Real-World Applications:**
- Try alternative architectures or styles
- Pressure-test design decisions
- Find similar bugs or deprecated patterns

---

### üìê OpenAI Codex Best Practices

**Workflow Practices:**
- Use Ask Mode first, then Code Mode
- Mirror GitHub Issue format in prompts
- Use AGENTS.md for persistent context
- Maintain a Codex task queue for async handoffs
- Use Best-of-N generation for solution diversity

**Novel Organizational Practices:**
- ‚≠ê **AGENTS.md for AI Personalization**: Persistent context and preferences
- ‚≠ê **Backlog-Driven Prompting**: Maintain flow through structured task management

---

## Anthropic Claude Code Practices

### üîß 1. Data Infrastructure
**Core Capability:** Cross-functional infrastructure management

**Traditional Methods:**
- Technical team dependency
- Manual documentation
- Sequential debugging

**AI-Native Methods:**
- ‚≠ê **Screenshot-Based Kubernetes Diagnosis**: Visual debugging without CLI expertise
- ‚≠ê **Plain Text Workflow Execution**: Non-technical teams executing technical tasks
- ‚≠ê **Parallel Sessions with Memory**: Multiple concurrent workstreams with context retention

**Impact:** Cross-team autonomy, accelerated onboarding

**Real-World Applications:**
- Kubernetes debugging via screenshots
- Plain text workflow execution for finance teams
- Codebase navigation for new hires
- Automated documentation summaries
- Parallel workflow sessions with memory

---

### üí° 2. Product Development
**Core Capability:** Autonomous feature development

**Traditional Methods:**
- Developer-only implementation
- Sequential development cycles
- Manual code review

**AI-Native Methods:**
- ‚≠ê **Auto-Accept Loops**: AI works autonomously with minimal oversight
- ‚≠ê **70% Feature Development by AI**: Major features primarily AI-implemented

**Impact:** Rapid innovation & clean code

**Real-World Applications:**
- Auto-accept mode for rapid prototyping
- Autonomous feature building (e.g., Vim mode)
- Synchronous co-coding for core logic
- AI-driven test generation
- Async codebase exploration

---

### üîê 3. Security Engineering
**Core Capability:** Security-first development workflows

**Traditional Methods:**
- Manual security review
- Post-development security audits
- Separate documentation process

**AI-Native Methods:**
- ‚≠ê **Markdown-Based Test-First Workflows**: Documentation-driven security development
- ‚≠ê **AI Autonomous Security Work**: AI "talks first" for security implementations
- ‚≠ê **50% Custom Slash Commands Usage**: Streamlined security tooling

**Impact:** Faster security approvals & better documentation

**Real-World Applications:**
- Incident debugging via stack trace tracing
- Terraform infrastructure review + security questions
- Markdown runbook synthesis
- Test-first pseudocode writing workflow
- Custom slash commands & AI autonomy

---

### üß† 4. Inference & Learning
**Core Capability:** Accelerated technical learning

**Traditional Methods:**
- Manual language learning
- Documentation research
- Expert consultation

**AI-Native Methods:**
- ‚≠ê **On-Demand Language Switching**: Work in unfamiliar languages without learning
- ‚≠ê **80% Reduction in ML Research Time**: Instant concept comprehension

**Impact:** Accelerated learning & onboarding

**Real-World Applications:**
- Codebase comprehension for ML onboarding
- Cross-language translation (e.g., Rust)
- ML concept explanation for non-experts
- Command recall (Kubernetes, etc.)

---

### üìä 5. Data Science & ML Engineering
**Core Capability:** Full-stack development without expertise

**Traditional Methods:**
- Full-stack skill requirements
- Sequential learning
- Limited tool creation

**AI-Native Methods:**
- ‚≠ê **Zero-Knowledge Production UI Delegation**: Complex interfaces without prior experience
- ‚≠ê **Slot Machine-Style Experimentation**: Rapid iteration workflows

**Impact:** Complex tool creation without full-stack skills

**Real-World Applications:**
- React dashboards without JavaScript knowledge
- Refactor tasks via AI-as-slot-machine
- Reusable dashboards vs throwaway notebooks
- Zero-dependency delegation for entire tasks

---

### ‚öôÔ∏è 6. Product Engineering
**Core Capability:** Independent debugging and development

**Traditional Methods:**
- Domain expertise requirements
- Context switching for help
- Sequential debugging

**AI-Native Methods:**
- ‚≠ê **Real-Time Model Dogfooding**: AI system improvement through usage
- ‚≠ê **Independent Bug Fixing**: Resolve issues in unfamiliar systems

**Impact:** Deep productivity gains and developer confidence

**Real-World Applications:**
- AI as first-stop debug guide
- Bug fixing in unfamiliar systems independently
- Dogfooding via model iteration
- No context switching with embedded AI use

---

### üìà 7. Growth Marketing
**Core Capability:** Scaled creative and analytical operations

**Traditional Methods:**
- Manual creative generation
- Sequential campaign testing
- Team-dependent analytics

**AI-Native Methods:**
- ‚≠ê **Automated Sub-Agents for Creative Generation**: Headlines/descriptions at scale
- ‚≠ê **Persistent Memory for Creative Iteration**: Continuous improvement loops
- ‚≠ê **Figma Plugin for 100+ Creatives per Second**: Mass visual variation

**Impact:** 10x output with 1-person team

**Real-World Applications:**
- Google Ads agentic copy generation
- Figma plugin for visual variation at scale
- MCP-integrated campaign analytics
- Memory-driven iterative ad testing framework

---

### üßë‚Äçüé® 8. Product Design
**Core Capability:** Direct design-to-code implementation

**Traditional Methods:**
- Designer-developer handoffs
- Static mockups
- Implementation gaps

**AI-Native Methods:**
- ‚≠ê **Designers Managing State Code Changes**: Direct implementation by designers
- ‚≠ê **Functional Prototypes from Mockups**: Paste-to-working-code workflow
- ‚≠ê **Memory Files for Non-Coder AI Adaptation**: Behavioral customization

**Impact:** Faster cycles, improved collaboration

**Real-World Applications:**
- Direct implementation of design tweaks
- Auto-GitHub fixes via issue tickets
- Prototyping via image pasting + state mapping
- Designers creating functional code directly

---

### ü§ñ 9. RL Engineering
**Core Capability:** Experimental development with safety nets

**Traditional Methods:**
- Careful manual implementation
- Conservative development
- Limited experimentation

**AI-Native Methods:**
- ‚≠ê **Frequent Rollback Checkpoints**: Support AI experimentation safely
- ‚≠ê **One-Shot Implementation**: AI attempts before human iteration

**Impact:** Faster iteration and experimentation

**Real-World Applications:**
- Try & rollback workflow with checkpoints
- Autonomous feature attempts (1/3 success rate)
- Automated commenting + code review
- Kubernetes support via AI

---

### ‚öñÔ∏è 10. Legal
**Core Capability:** Technical prototyping for non-technical teams

**Traditional Methods:**
- Engineering dependency
- Limited prototyping capability
- External development requirements

**AI-Native Methods:**
- ‚≠ê **Predictive Accessibility Tools**: Personal use case solutions
- ‚≠ê **Two-Step Brainstorming-to-Build Pipeline**: Rapid concept validation
- ‚≠ê **External Expert Validation**: AI prototypes reviewed by domain experts

**Impact:** Prototyping without engineers

**Real-World Applications:**
- Custom accessibility apps (predictive speech)
- Internal tools for lawyer routing
- Prototype review by external experts (e.g., UCSF)
- G Suite automation for legal workflows

---

## Novel Practices Summary

### üåü Revolutionary AI-Native Practices

#### Infrastructure & Operations
- Screenshot-based debugging and diagnosis
- Plain text workflow execution by non-technical teams
- Parallel memory-aware session handling
- Visual-first system management

#### Development & Engineering
- Auto-accept loops for autonomous development
- Mass code changes with automated PR generation
- Performance bottleneck detection and fixing in one step
- Cross-language delegation without learning

#### Cross-Team Collaboration
- Non-coder workflow execution across departments
- Designers managing state code changes themselves
- Legal teams creating technical prototypes
- Marketing teams generating production-ready creative at scale

#### Workflow & Process Innovation
- Prompt-based flow capture and revisit
- Memory-driven iterative improvement
- Slot machine-style experimentation workflows
- Role-tailored AI behavior modification via markdown files

#### Quality & Testing
- Autogenerated test PRs during downtime
- CI acceleration through AI handoffs
- Test-first pseudocode writing workflows
- Markdown-based documentation-driven development

---

## Learning Path Organization

### Beginner Level: Understanding AI-Native Mindset
1. Traditional vs AI-Native approaches
2. Basic prompt engineering for code tasks
3. Simple automation and scaffolding
4. Context management basics

### Intermediate Level: Workflow Integration
1. Multi-step AI workflows
2. Cross-team collaboration patterns
3. Memory and context persistence
4. Tool integration and automation

### Advanced Level: Organizational Transformation
1. Department-specific AI-native practices
2. Parallel workflow management
3. Autonomous development loops
4. Cultural and process transformation

### Expert Level: Novel Practice Innovation
1. Creating new AI-native patterns
2. Custom tooling and integration
3. Advanced memory and context systems
4. Organizational AI strategy

---

## Implementation Considerations

### Technical Requirements
- AI model access and configuration
- Context and memory management systems
- Integration with existing development tools
- Security and access control frameworks

### Organizational Changes
- Role redefinition and skill development
- Workflow and process updates
- Cross-team collaboration models
- Performance and success metrics

### Cultural Transformation
- Embracing autonomous AI collaboration
- Trust in AI-generated solutions
- New quality assurance approaches
- Continuous learning and adaptation

---

## Conclusion

The practices documented here represent a fundamental shift in how software development, debugging, and cross-functional collaboration occur in organizations leveraging advanced AI systems. These are not incremental improvements but entirely new paradigms that require both technical implementation and organizational transformation.

The key insight is that AI-native organizations don't just use AI as a tool‚Äîthey restructure their entire approach to work around AI's unique capabilities, creating workflows and practices that would be impossible without AI collaboration.
