MCPToolCallingCode Explanation
--------------------------------------------------------------------------------

Beginner Explanation
--------------------------------------------------------------------------------
This page shows you the actual code that makes tool-calling work. On the left, you see the code for the "MCP Server," which is the program that makes the tool available. In this case, the tool can get the price of a product. On the right, you see the code for the "MCP Client," which is the AI assistant that uses the tool. This shows you how developers write code to connect an AI to a tool so it can answer your questions more accurately.

--------------------------------------------------------------------------------
Intermediate Explanation
--------------------------------------------------------------------------------
This page provides a side-by-side view of the code for a complete MCP tool-calling implementation. The "MCP Server" code on the left defines a `ProductPriceServer` with two tools: `get_product_price` and `list_products`. It also includes a mock database to simulate a real-world data source. The "MCP Client" code on the right shows an `IntelligentPriceAssistant`. This client connects to the MCP server, discovers its available tools, and then uses an OpenAI model to process user queries. When the model decides a tool is needed, the client makes the call to the MCP server and incorporates the result into its final response.

--------------------------------------------------------------------------------
Advanced Explanation
--------------------------------------------------------------------------------
This `MCPToolCallingCode` component displays two extensive Python code blocks for a full-stack MCP implementation. The `ProductPriceServer` class on the left is a complete example of an MCP server, using decorators to define tools and including a mock database. The `IntelligentPriceAssistant` class on the right is a sophisticated MCP client. It dynamically creates the tool definitions required for the OpenAI API's function-calling feature from the tools it discovers on the MCP server. The `process_user_query` method demonstrates the full, multi-step LLM interaction loop: the first call to the LLM to generate the tool call, the execution of the tool call via the MCP client, and the final call to the LLM with the tool's output to generate the user-facing response.
